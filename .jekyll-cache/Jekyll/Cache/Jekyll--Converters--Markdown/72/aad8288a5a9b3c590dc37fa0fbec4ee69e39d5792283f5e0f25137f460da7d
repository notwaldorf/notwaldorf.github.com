I"XO<p><strong>Updated May 18, 2020</strong></p>

<p>(get it? <code class="language-plaintext highlighter-rouge">::</code> ? I made a funny)</p>

<p><a href="https://meowni.ca/posts/shadow-dom/">Shadow DOM</a> is a spec that gives you DOM and style encapsulation. This is great for reusable <a href="https://meowni.ca/posts/web-components-with-otters/">web components</a>, as it reduces the ability of these components‚Äô styles getting accidentally stomped over (the old <em>‚ÄúI have a class called ‚Äúbutton‚Äù and you have a class called ‚Äúbutton‚Äù, now we both look busted‚Äù</em> problem), but it adds a barrier for styling and theming these components deliberately.</p>

<p>Since a lot has changed since the <a href="https://meowni.ca/posts/styling-the-dome/">last time</a> I talked about styling the Shadow DOM, I wanted to give you a quick update about what new specs were in the works! Please note that this spec <strong>isn‚Äôt</strong> quite final, which means that a) the syntax and capabilities will likely change and b) there isn‚Äôt a polyfill you can use for realsies.</p>

<hr />

<p>Ok, so. When talking about styling a component, there are usually two different problems you might want to solve:</p>

<p><strong>üíá Styling:</strong> I am using a third-party <code class="language-plaintext highlighter-rouge">&lt;fancy-button&gt;</code> element on my site and I want this one to be blue</p>

<p><strong>üé® Theming:</strong> I am using many third-party elements on my site, and some of them have a <code class="language-plaintext highlighter-rouge">&lt;fancy-button&gt;</code>; I want all the <code class="language-plaintext highlighter-rouge">&lt;fancy-button&gt;</code>s to be blue.</p>

<p>Here‚Äôs almost everything I know on this topic.</p>

<h2 id="a-trip-through-time">A trip through time</h2>
<p>There have been several previous attempts at solving this, some more successful than others. If you‚Äôve read my <a href="https://meowni.ca/posts/styling-the-dome/">last</a> post about this, you‚Äôre already caught up. If you haven‚Äôt, here‚Äôs the deets:</p>

<ul>
  <li>
    <p>First came <code class="language-plaintext highlighter-rouge">:shadow</code> and <code class="language-plaintext highlighter-rouge">/deep/</code> (which have since been deprecated, and removed as of Chrome 60). These were shadow-piercing selectors that allowed you to target any node in an element‚Äôs Shadow DOM. Apart from being terribad for performance, they also required the user of an element to be intimately familiar with some random element‚Äôs implementation, which was unlikely and lead to them just breaking the whole element by accident</p>
  </li>
  <li>
    <p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/--*">Custom properties</a> allow you to create custom CSS properties that can be used throughout an app. In particular, they pierce the shadow boundary, which means they can be used for styling elements with a Shadow DOM:
If <code class="language-plaintext highlighter-rouge">&lt;fancy-button&gt;</code> uses a <code class="language-plaintext highlighter-rouge">--fancy-button-background</code> property to control its background, then:</p>
  </li>
</ul>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">fancy-button</span><span class="nf">#one</span> <span class="p">{</span> <span class="py">--fancy-button-background</span><span class="p">:</span> <span class="no">blue</span><span class="p">;</span> <span class="p">}</span> <span class="c">/* solves the üíá  problem and */</span>
<span class="nt">fancy-button</span> <span class="p">{</span> <span class="py">--fancy-button-background</span><span class="p">:</span> <span class="no">blue</span><span class="p">;</span> <span class="p">}</span> <span class="c">/* solves the üé®  problem */</span>
</code></pre></div></div>

<ul>
  <li>The problem with using just custom properties for styling/theming is that it places the onus on the element author to basically declare every possible styleable property as a custom property. As a result, <a href="http://tabatkins.github.io/specs/css-apply-rule/">@apply</a> was proposed, which basically allowed a custom property to hold an entire ruleset (a bag of other properties!). <a href="https://twitter.com/tabatkins">Tab Atkins</a> has a very good <a href="https://www.xanthir.com/b4o00">post</a> as to why this approach was abandoned, but the tl;dr; is that it interacted pretty poorly with pseudo classes and elements (like <code class="language-plaintext highlighter-rouge">:focus</code>, <code class="language-plaintext highlighter-rouge">:hover</code>, <code class="language-plaintext highlighter-rouge">::placeholder</code> for input), which still meant the element author would have to define a looooot of these bags of properties to be used in the right places.</li>
</ul>

<h2 id="and-now-something-different-but-the-same">And now: something different but the same</h2>

<p>The current new proposal is <a href="https://drafts.csswg.org/css-shadow-parts-1/">::part</a> (and possibly later, <code class="language-plaintext highlighter-rouge">::theme</code>), a set of pseudo-elements that allow you to style inside a shadow tree, from outside of that shadow tree. Unlike <code class="language-plaintext highlighter-rouge">:shadow</code> and <code class="language-plaintext highlighter-rouge">/deep/</code>, they don‚Äôt allow you to style arbitrary elements inside a shadow tree: they only allow you to style elements that an author has tagged as being eligible for styling. They‚Äôve already gone through the CSS working group and were blessed, and were brought up at TPAC at a Web Components session, so we‚Äôre confident they‚Äôre both the right approach, and highly likely to be implemented as a spec by all browsers, though there is some discussion of the exact selector syntax still going on.</p>

<h2 id="how-part-works">How ::part works</h2>
<p>You can specify a ‚Äústyleable‚Äù part on any element in your shadow tree:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;x-foo&gt;</span>
  #shadow-root
    <span class="nt">&lt;div</span> <span class="na">part=</span><span class="s">"some-box"</span><span class="nt">&gt;&lt;span&gt;</span>...<span class="nt">&lt;/span&gt;&lt;/div&gt;</span>
    <span class="nt">&lt;input</span> <span class="na">part=</span><span class="s">"some-input"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;div&gt;</span>...<span class="nt">&lt;/div&gt;</span> <span class="c">&lt;!-- not styleable --&gt;</span>
<span class="nt">&lt;/x-foo&gt;</span>
</code></pre></div></div>

<p>If you‚Äôre in a document that has an <code class="language-plaintext highlighter-rouge">&lt;x-foo&gt;</code> in it, then you can style those parts with:</p>
<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">x-foo</span><span class="nd">::part</span><span class="o">(</span><span class="nt">some-box</span><span class="o">)</span> <span class="p">{</span> <span class="err">...</span> <span class="p">}</span>
</code></pre></div></div>

<p>You <strong>can</strong> use other pseudo elements or selectors (that were not explicitly exposed as shadow parts), so both of these work:</p>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">x-foo</span><span class="nd">::part</span><span class="o">(</span><span class="nt">some-box</span><span class="o">)</span><span class="nd">:hover</span> <span class="p">{</span> <span class="err">...</span> <span class="p">}</span>
<span class="nt">x-foo</span><span class="nd">::part</span><span class="o">(</span><span class="nt">some-input</span><span class="o">)</span><span class="nd">::placeholder</span> <span class="p">{</span> <span class="err">...</span> <span class="p">}</span>
</code></pre></div></div>

<p>You <strong>cannot</strong> select inside of those parts, so this <strong>doesn‚Äôt</strong> work:</p>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">x-foo</span><span class="nd">::part</span><span class="o">(</span><span class="nt">some-box</span><span class="o">)</span> <span class="nt">span</span> <span class="p">{</span> <span class="err">...</span> <span class="p">}</span> <span class="nt">nor</span>
<span class="nt">x-foo</span><span class="nd">::part</span><span class="o">(</span><span class="nt">some-box</span><span class="o">)</span><span class="nd">::part</span><span class="o">(</span><span class="nt">some-other-thing</span><span class="o">)</span> <span class="p">{</span> <span class="err">...</span> <span class="p">}</span>
</code></pre></div></div>

<p>You <strong>cannot</strong> style this part more than one level up if you don‚Äôt forward it. So without any extra work, if you have an element that contains an <code class="language-plaintext highlighter-rouge">x-foo</code> like this:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;x-bar&gt;</span>
  #shadow-root
    <span class="nt">&lt;x-foo&gt;&lt;/x-foo&gt;</span>
<span class="nt">&lt;/x-bar&gt;</span>
</code></pre></div></div>

<p>You <strong>cannot</strong> select and style the <code class="language-plaintext highlighter-rouge">x-foo</code>‚Äôs part like this:</p>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">x-bar</span><span class="nd">::part</span><span class="o">(</span><span class="nt">some-box</span><span class="o">)</span> <span class="p">{</span> <span class="err">...</span> <span class="p">}</span>
</code></pre></div></div>

<h3 id="forwarding-parts">Forwarding parts</h3>
<p>You <strong>can</strong> explicitly forward a child‚Äôs part to be styleable outside of the parent‚Äôs shadow tree with the <code class="language-plaintext highlighter-rouge">exportparts</code> attribute. So in the previous example, to allow the <code class="language-plaintext highlighter-rouge">some-box</code> part to be styleable by <code class="language-plaintext highlighter-rouge">x-bar</code>‚Äôs parent, it would have to be exposed:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;x-bar&gt;</span>
  #shadow-root
    <span class="nt">&lt;x-foo</span> <span class="na">exportparts=</span><span class="s">"some-box"</span><span class="nt">&gt;&lt;/x-foo&gt;</span>
<span class="nt">&lt;/x-bar&gt;</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">exportparts</code> forwarding syntax has options a-plenty. üôè Feel free to skip these if
you‚Äôre not interested in the minutiae of the syntax!</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">exportparts="some-box some-input"</code>: explicitly forward <code class="language-plaintext highlighter-rouge">x-foo</code>‚Äôs parts that you know about (i.e. <code class="language-plaintext highlighter-rouge">some-box</code> and <code class="language-plaintext highlighter-rouge">some-input</code>) as they are. These selectors <strong>would</strong> match:</p>

    <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">x-bar</span><span class="nd">::part</span><span class="o">(</span><span class="nt">some-box</span><span class="o">)</span> <span class="p">{</span> <span class="err">...</span> <span class="p">}</span>
<span class="nt">x-bar</span><span class="nd">::part</span><span class="o">(</span><span class="nt">some-input</span><span class="o">)</span> <span class="p">{</span> <span class="err">...</span> <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">exportparts="some-input: bar-input"</code>: explicitly forward (some) of <code class="language-plaintext highlighter-rouge">x-foo</code>‚Äôs parts (i.e. <code class="language-plaintext highlighter-rouge">some-input</code>) but rename them. These selectors <strong>would</strong> match:</p>

    <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">x-bar</span><span class="nd">::part</span><span class="o">(</span><span class="nt">bar-input</span><span class="o">)</span> <span class="p">{</span> <span class="err">...</span> <span class="p">}</span>
</code></pre></div>    </div>
    <p>These selectors would <strong>not</strong> match:</p>
    <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">x-bar</span><span class="nd">::part</span><span class="o">(</span><span class="nt">some-box</span><span class="o">)</span> <span class="p">{</span> <span class="err">...</span> <span class="p">}</span>
<span class="nt">x-bar</span><span class="nd">::part</span><span class="o">(</span><span class="nt">some-input</span><span class="o">)</span> <span class="p">{</span> <span class="err">...</span> <span class="p">}</span>
<span class="nt">x-bar</span><span class="nd">::part</span><span class="o">(</span><span class="nt">bar-box</span><span class="o">)</span> <span class="p">{</span> <span class="err">...</span> <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>You <em>can</em> combine these, as well as add a part to <code class="language-plaintext highlighter-rouge">x-foo</code> itself (<code class="language-plaintext highlighter-rouge">some-foo</code> below. This means ‚Äústyle this particular <code class="language-plaintext highlighter-rouge">x-foo</code>, but not the other one, if you had more):</p>

    <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;x-bar&gt;</span>
  #shadow-root
    <span class="nt">&lt;x-foo</span> <span class="na">part=</span><span class="s">"some-foo"</span> <span class="na">exportparts=</span><span class="s">"some-input: bar-input"</span><span class="nt">&gt;&lt;/x-foo&gt;</span>
<span class="nt">&lt;/x-bar&gt;</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="the-all-buttons-in-this-app-should-be-blue--theming-problem">The ‚Äúall buttons in this app should be blue‚Äù üé® theming problem</h2>
<p>Given the above prefixing rules, to style all inputs in a document at once, you need to
Ensure that all elements correctly forward their parts and
Select all their parts.</p>

<p>So given this shadow tree:</p>
<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;submit-form&gt;</span>
  #shadow-root
    <span class="nt">&lt;x-form</span> <span class="na">exportparts=</span><span class="s">"some-input some-box"</span><span class="nt">&gt;</span>
      #shadow-root
        <span class="nt">&lt;x-bar</span> <span class="na">exportparts=</span><span class="s">"some-input some-box"</span><span class="nt">&gt;</span>
          #shadow-root
            <span class="nt">&lt;x-foo</span> <span class="na">exportparts=</span><span class="s">"some-input some-box"</span><span class="nt">&gt;&lt;/x-foo&gt;</span>
        <span class="nt">&lt;/x-bar&gt;</span>
    <span class="nt">&lt;/x-form&gt;</span>
<span class="nt">&lt;/submit-form&gt;</span>

<span class="nt">&lt;x-form&gt;&lt;/x-form&gt;</span>
<span class="nt">&lt;x-bar&gt;&lt;/x-bar&gt;</span>
</code></pre></div></div>

<p>You can style all the inputs with:</p>
<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">:root::part</span><span class="o">(</span><span class="nt">some-input</span><span class="o">)</span> <span class="p">{</span> <span class="err">...</span> <span class="p">}</span>
</code></pre></div></div>

<p>üëâ This is a lot of effort on the element author, but easy on the theme user.</p>

<p>If you hadn‚Äôt forwarded them with the same name and <code class="language-plaintext highlighter-rouge">some-input</code> was used at every level of the app (the non contrived example is just an <code class="language-plaintext highlighter-rouge">&lt;a&gt;</code> tag that‚Äôs used in many shadow roots), then you‚Äôd have to write:</p>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">:root::part</span><span class="o">(</span><span class="nt">form-bar-foo-some-input</span><span class="o">),</span>
<span class="nd">:root::part</span><span class="o">(</span><span class="nt">bar-foo-some-input</span><span class="o">,</span>
<span class="nd">:root::part</span><span class="o">(</span><span class="nt">foo-some-input</span><span class="o">),</span>
<span class="nd">:root::part</span><span class="o">(</span><span class="nt">some-input</span><span class="o">)</span> <span class="p">{</span> <span class="err">...</span> <span class="p">}</span>
</code></pre></div></div>

<p>üëâ This is a lot of effort on the theme user, but easy on the element author.</p>

<p>Both of these examples show that if an element author forgot to forward a part, then the app can‚Äôt be themed correctly.</p>

<h2 id="how-theme-might-work">How ::theme might work</h2>
<p><code class="language-plaintext highlighter-rouge">::theme</code> is another pseudoelement originally proposed to pair with <code class="language-plaintext highlighter-rouge">::part</code>. It matches any parts with that name, anywhere in the document. This means that if you hadn‚Äôt forwarded any parts, i.e.:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;x-bar&gt;</span>
  #shadow-root
    <span class="nt">&lt;x-foo&gt;&lt;/x-foo&gt;</span>
    <span class="nt">&lt;x-foo&gt;&lt;/x-foo&gt;</span>
    <span class="nt">&lt;x-foo&gt;&lt;/x-foo&gt;</span>
<span class="nt">&lt;/x-bar&gt;</span>
</code></pre></div></div>

<p>You could style all of the inputs in x-bar with:</p>
<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">x-bar</span><span class="nd">::theme</span><span class="o">(</span><span class="nt">some-input</span><span class="o">)</span> <span class="p">{</span> <span class="err">...</span> <span class="p">}</span>
</code></pre></div></div>

<p>This can go arbitrarily deep in the shadow tree. So, no matter how deeply nested they are, you could style all the inputs with <code class="language-plaintext highlighter-rouge">part="some-input"</code> in the app with:</p>
<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">:root::theme</span><span class="o">(</span><span class="nt">some-input</span><span class="o">)</span> <span class="p">{</span> <span class="err">...</span> <span class="p">}</span>   
</code></pre></div></div>

<h2 id="demo">Demo</h2>
<p>As mentioned before, this spec is still in the works and we don‚Äôt have a shim that you can use in production. Hell, this shim isn‚Äôt even guaranteed to work for all the cases that should work according to the spec, so you should take this code with an enormous iceberg of salt. This is a <a href="https://part-theme.glitch.me/">demo</a> that illustrates styling and theming a bunch of vanilla custom elements in a form.</p>

<p>Some notes:</p>

<ul>
  <li>
    <p>this shim is meant for a demo prototype of the (still in the works) API. it is a very very very very rough shim, which means its performance is badly in the weeds (don‚Äôt use it in production. don‚Äôt use it for anything you care about)</p>
  </li>
  <li>
    <p>it probably has bugs and doesn‚Äôt implement the spec 100%, and nobody will fix these bugs. Again, this shim wasn‚Äôt ever meant to be used for realsies</p>
  </li>
  <li>
    <p>the shim is implemented as a mixin, which means you can only use <code class="language-plaintext highlighter-rouge">::part</code> or <code class="language-plaintext highlighter-rouge">::theme</code> inside of a custom element using that mixin (see <code class="language-plaintext highlighter-rouge">another-form.js</code>)</p>
  </li>
</ul>
:ET